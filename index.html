<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Колесо</title>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            color: white;
        }
        
        .container {
            max-width: 900px;
            width: 100%;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            margin-bottom: 20px;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        
        .wheel-container {
            position: relative;
            width: 400px;
            height: 400px;
            margin: 0 auto 30px;
        }
        
        .wheel {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            transition: transform 5s cubic-bezier(0.17, 0.67, 0.83, 0.67);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 0 2px rgba(255, 255, 255, 0.3);
            border: 10px solid #2c3e50;
        }
        
        .wheel-item {
            position: absolute;
            width: 50%;
            height: 50%;
            transform-origin: bottom right;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        .wheel-item.yes {
            background: #27ae60;
        }
        
        .wheel-item.no {
            background: #e74c3c;
        }
        
        .wheel-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: #2c3e50;
            border-radius: 50%;
            z-index: 10;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        
        .pointer {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 15px solid transparent;
            border-right: 15px solid transparent;
            border-top: 40px solid #FFD700;
            filter: drop-shadow(0 0 5px rgba(255, 215, 0, 0.8));
            z-index: 11;
        }
        
        .controls {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .input-group {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 300px;
        }
        
        label {
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        input, button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            font-size: 16px;
        }
        
        input {
            background: rgba(255, 255, 255, 0.9);
        }
        
        button {
            background: #3498db;
            color: white;
            cursor: pointer;
            transition: background 0.3s;
            font-weight: bold;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        button:disabled {
            background: #7f8c8d;
            cursor: not-allowed;
        }
        
        .result {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            min-height: 40px;
            margin: 15px 0;
            color: #FFD700;
        }
        
        .firebase-config {
            width: 100%;
            margin-top: 30px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        .firebase-config h2 {
            margin-bottom: 15px;
            color: #FFA500;
        }
        
        textarea {
            width: 100%;
            height: 150px;
            padding: 10px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.9);
            margin-bottom: 15px;
            resize: vertical;
            font-family: monospace;
        }
        
        .status {
            text-align: center;
            margin-top: 10px;
            font-weight: bold;
        }
        
        .connected {
            color: #2ecc71;
        }
        
        .disconnected {
            color: #e74c3c;
        }
        
        .online-count {
            text-align: center;
            margin-top: 10px;
            font-size: 16px;
            color: #3498db;
        }
        
        .history {
            margin-top: 30px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            padding: 15px;
        }
        .history h2 {
            margin-bottom: 10px;
            color: #FFA500;
        }
        .history-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            max-height: 300px;
            overflow-y: auto;
        }
        .history-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 8px;
            padding: 8px 10px;
            font-size: 14px;
        }
        .history-item .meta {
            color: #bdc3c7;
            margin-right: 10px;
            white-space: nowrap;
        }
        .history-item .reason {
            flex: 1;
            color: #ecf0f1;
            margin: 0 10px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .history-item .result {
            font-weight: bold;
        }
        
        .spoiler {
            color: transparent;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 4px;
            padding: 0 4px;
            cursor: pointer;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
            user-select: none;
        }
        .spoiler.revealed {
            color: inherit;
            background: transparent;
            text-shadow: none;
            user-select: text;
        }
        
        /* Chat widget */
        .chat-widget {
            position: fixed;
            right: 20px;
            bottom: 20px;
            width: 320px;
            max-height: 50vh;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            z-index: 50;
            transition: left 0.25s ease, top 0.25s ease, right 0.25s ease, bottom 0.25s ease, width 0.25s ease, margin 0.25s ease, max-height 0.25s ease, transform 0.25s ease, opacity 0.25s ease;
        }
        .chat-header {
            padding: 8px 10px;
            background: rgba(255,255,255,0.08);
            border-bottom: 1px solid rgba(255,255,255,0.15);
            font-weight: bold;
            cursor: move;
            user-select: none;
        }
        .chat-messages {
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow-y: auto;
            flex: 1;
        }
        .chat-input {
            display: flex;
            gap: 8px;
            padding: 10px;
            border-top: 1px solid rgba(255,255,255,0.15);
            background: rgba(255,255,255,0.06);
        }
        .chat-input input[type="text"] {
            flex: 1;
            background: rgba(255,255,255,0.9);
            border-radius: 6px;
            padding: 8px 10px;
            color: #2c3e50;
        }
        .chat-send-btn {
            background: #2ecc71;
            color: #1b2a3a;
            border-radius: 6px;
            font-weight: bold;
        }
        .chat-message {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            max-width: 85%;
            padding: 6px 8px;
            border-radius: 8px;
            background: rgba(255,255,255,0.1);
        }
        .chat-message.me {
            align-self: flex-end;
            background: rgba(46, 204, 113, 0.2);
        }
        .chat-meta {
            font-size: 11px;
            color: #bdc3c7;
            margin-top: 2px;
        }
        .chat-meta .read-indicator {
            margin-left: 6px;
            color: #2ecc71;
            font-weight: 600;
        }
        .chat-message .read-indicator {
            margin-left: auto;
            color: #2ecc71;
            font-weight: 600;
            font-size: 12px;
        }
        .chat-typing {
            padding: 6px 10px;
            font-size: 12px;
            color: #bdc3c7;
        }
        
        /* PIN overlay */
        .pin-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 100;
            backdrop-filter: blur(2px);
        }
        .pin-overlay.active {
            display: flex;
        }
        .pin-modal {
            width: 90%;
            max-width: 360px;
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 12px;
            padding: 16px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
        }
        .pin-modal h3 {
            margin-bottom: 8px;
            color: #FFD700;
            text-align: center;
        }
        .pin-modal p {
            margin-bottom: 12px;
            color: #ecf0f1;
            text-align: center;
            font-size: 14px;
        }
        .pin-field {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            justify-content: center;
        }
        .pin-field input[type="password"] {
            width: 40px;
            height: 48px;
            text-align: center;
            font-size: 22px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.9);
            color: #2c3e50;
        }
        .pin-actions {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        .pin-actions button {
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
        }
        .pin-error {
            color: #e74c3c;
            text-align: center;
            min-height: 18px;
            margin-top: 6px;
            font-size: 13px;
        }
        
        /* Mobile placement */
        @media (max-width: 600px) {
            .wheel-container {
                width: 300px;
                height: 300px;
            }
            
            .history-item {
                flex-direction: column;
                gap: 5px;
                text-align: center;
            }
            
            .history-item .meta {
                font-size: 12px;
                margin-right: 0;
            }
            
            .history-item .reason {
                font-size: 14px;
                margin: 0;
                white-space: normal;
                text-overflow: unset;
            }
            
            .history-item .result {
                font-size: 16px;
            }
            
            .history-list {
                max-height: 250px;
            }
            .chat-widget {
                position: static;
                width: 100%;
                max-height: none;
                margin-top: 12px;
            }
            .chat-header {
                cursor: default;
            }
        }
        /* Chat becomes non-widget on narrower screens */
        @media (max-width: 1000px) {
            .chat-widget {
                position: static;
                width: 100%;
                max-height: none;
                margin-top: 12px;
                left: auto;
                top: auto;
                right: auto;
                bottom: auto;
            }
            .chat-header {
                cursor: default;
            }
        }
        /* Footer */
        .site-footer {
            margin-top: 24px;
            padding: 12px 14px;
            border-top: 1px solid rgba(255,255,255,0.15);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            color: #bdc3c7;
        }
        .site-footer a {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            color: #bdc3c7;
        }
        .site-footer a:hover {
            color: #ffffff;
        }
        .footer-avatar {
            width: clamp(28px, 6vw, 40px);
            height: clamp(28px, 6vw, 40px);
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.25);
            box-shadow: 0 2px 8px rgba(0,0,0,0.35);
            object-fit: cover;
        }
        .footer-text {
            font-size: clamp(12px, 2.2vw, 14px);
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>колесико крутить онлайн</h1>
        
        <div class="input-group" style="margin: 0 auto 15px; max-width: 500px;">
            <label for="reason">Повод:</label>
            <input type="text" id="reason" placeholder=" повод...">
        </div>
        
        <div class="wheel-container">
            <div class="pointer"></div>
            <div class="wheel" id="wheel"></div>
            <div class="wheel-center">УРА ГОЛ ПОБЕДА ЕЕЕЕ</div>
        </div>
        
        <div class="result" id="result"></div>
        
        <div class="controls">
            <div class="input-group">
                <label for="yesCount">МАКС (0–9):</label>
                <input type="number" id="noCountInput" min="0" max="9" value="0">
            </div>
            
            <button id="spinBtn">Крутить</button>
        </div>
        
        <div class="firebase-config">
            <h2>Настройка Firebase</h2>
            <p>Вставьте конфигурацию Firebase для синхронизации состояния колеса:</p>
            <textarea id="firebaseConfig" placeholder="Вставьте конфигурационный объект Firebase здесь..."></textarea>
            <button id="saveConfigBtn">Сохранить конфигурацию</button>
            <div id="connectionStatus" class="status disconnected">Не подключено</div>
            <div id="onlineCount" class="online-count">Пользователей онлайн: 0</div>
            
            <div id="chatWidget" class="chat-widget" aria-live="polite">
                <div id="chatHeader" class="chat-header">Чат</div>
                <div id="chatMessages" class="chat-messages"></div>
                <div id="chatTyping" class="chat-typing" style="display:none;">Кто-то печатает…</div>
                <div class="chat-input">
                    <input id="chatInput" type="text" placeholder="Напишите сообщение..." />
                    <button id="chatSend" class="chat-send-btn">Отправить</button>
                </div>
            </div>
        </div>

        <div class="history">
            <h2>История круток</h2>
            <div id="historyList" class="history-list"></div>
        </div>
        <div class="pin-overlay" id="pinOverlay" aria-modal="true" role="dialog">
            <div class="pin-modal">
                <h3 id="pinTitle">Введите PIN</h3>
                <p id="pinSubtitle">Для доступа введите 6-значный PIN</p>
                <div class="pin-field" id="pinField"></div>
                <div class="pin-actions">
                    <button id="pinConfirm">Подтвердить</button>
                    <button id="pinReset">Сбросить PIN</button>
                </div>
                <div class="pin-error" id="pinError"></div>
            </div>
        </div>
        <div class="site-footer">
            <a href="https://github.com/echpochmakhackinggroup" target="_blank" rel="noopener noreferrer">
                <img class="footer-avatar" src="https://avatars.githubusercontent.com/u/121233723?v=4" alt="ECHG Avatar" />
                <span class="footer-text">echpochmakhackinggroup</span>
            </a>
        </div>
    </div>

    <script>
        // Элементы DOM
        const wheelElement = document.getElementById('wheel');
        const resultElement = document.getElementById('result');
        const yesCountInput = document.getElementById('noCountInput');
        const reasonInput = document.getElementById('reason');
        const spinBtn = document.getElementById('spinBtn');
        const firebaseConfigTextarea = document.getElementById('firebaseConfig');
        const saveConfigBtn = document.getElementById('saveConfigBtn');
        const connectionStatus = document.getElementById('connectionStatus');
        const onlineCountElement = document.getElementById('onlineCount');
        const historyListEl = document.getElementById('historyList');
        
        // Переменные состояния
        let isSpinning = false;
        let db = null;
        let wheelStateRef = null;
        let configRef = null;
        let connectedRef = null;
        let usersOnline = 0;
        let historyRef = null;
        let lastProcessedWheelTs = 0;
        
        // Chat elements
        const chatWidget = document.getElementById('chatWidget');
        const chatHeader = document.getElementById('chatHeader');
        const chatMessages = document.getElementById('chatMessages');
        const chatTyping = document.getElementById('chatTyping');
        const chatInput = document.getElementById('chatInput');
        const chatSend = document.getElementById('chatSend');
        
        // Chat refs
        let chatRootRef = null;
        let chatMessagesRef = null;
        let chatTypingRef = null;
        let myTypingRef = null;
        let myDeviceId = null;
        
        // Пример конфигурации Firebase (для подсказки)
        const exampleConfig = `{
  "apiKey": "your-api-key",
  "authDomain": "your-project.firebaseapp.com",
  "databaseURL": "https://your-project-default-rtdb.firebaseio.com",
  "projectId": "your-project",
  "storageBucket": "your-project.appspot.com",
  "messagingSenderId": "123456789",
  "appId": "your-app-id"
}`;
        
        firebaseConfigTextarea.placeholder = exampleConfig;
        
        // Инициализация колеса
        function initWheel(noCount) {
            wheelElement.innerHTML = '';
            wheelElement.style.transform = 'rotate(0deg)';
            
            const totalItems = 10;
            const anglePerItem = 360 / totalItems;
            const yesCount = 10 - noCount;
            let stops = [];
            for (let i = 0; i < totalItems; i++) {
                const start = i * anglePerItem;
                const end = start + anglePerItem;
                const color = i < yesCount ? '#27ae60' : '#e74c3c';
                stops.push(`${color} ${start}deg ${end}deg`);
                // Добавляем белые границы между секторами
                if (i < totalItems - 1) {
                    stops.push(`white ${end - 0.5}deg ${end + 0.5}deg`);
                }
            }
            wheelElement.style.background = `conic-gradient(${stops.join(', ')})`;
            
            resultElement.textContent = '';
        }
        
        // Кручение колеса
        function spinWheel() {
            if (isSpinning) return;
            
            isSpinning = true;
            spinBtn.disabled = true;
            resultElement.textContent = '';
            
            const noCount = parseInt(yesCountInput.value);
            const yesCount = 10 - noCount;
            const totalItems = 10;
            
            // Случайный угол вращения (минимум 5 полных оборотов)
            const rotations = 5 + Math.floor(Math.random() * 5);
            const randomItem = Math.floor(Math.random() * totalItems);
            const anglePerItem = 360 / totalItems;
            
            // Вычисляем угол так, чтобы колесо остановилось точно на секторе
            // Учитываем, что стрелка находится вверху (0 градусов)
            // Каждый сектор занимает anglePerItem градусов
            // Центр сектора должен совпасть с позицией стрелки (0 градусов)
            // Поэтому вычитаем позицию сектора от 0, чтобы сектор оказался под стрелкой
            const targetAngle = rotations * 360 - (randomItem * anglePerItem) - (anglePerItem / 2);
            
            // Анимация вращения
            wheelElement.style.transition = 'transform 5s cubic-bezier(0.17, 0.67, 0.83, 0.67)';
            wheelElement.style.transform = `rotate(${targetAngle}deg)`;
            
            // Сохранение состояния в Firebase
            if (wheelStateRef) {
                const state = {
                    spinning: true,
                    targetAngle: targetAngle,
                    result: randomItem < yesCount ? 'ДА' : 'NO',
                    timestamp: Date.now()
                };
                
                wheelStateRef.set(state);
            }
            
            // Отображение результата после завершения анимации
            setTimeout(() => {
                const result = randomItem < yesCount ? 'ДА' : 'NO';
                resultElement.textContent = `Результат: ${result}!`;
                isSpinning = false;
                spinBtn.disabled = false;
                
                if (wheelStateRef) {
                    wheelStateRef.update({ spinning: false });
                }
                
                // Сохраняем запись в историю (append-only)
                if (historyRef) {
                    const nowTs = Date.now();
                    historyRef.push({
                        timestamp: nowTs,
                        isoDate: new Date(nowTs).toISOString(),
                        yesCount: yesCount,
                        noCount: noCount,
                        totalItems: 10,
                        result: result,
                        targetAngle: targetAngle,
                        randomItem: randomItem,
                        reason: (typeof reasonInput?.value === 'string') ? reasonInput.value : ''
                    });
                }
            }, 5000);
        }
        
        // Инициализация Firebase
        function initFirebase(config) {
            try {
                // Очищаем предыдущее соединение
                if (db) {
                    firebase.database().goOffline();
                }
                
                // Инициализируем Firebase
                firebase.initializeApp(config);
                db = firebase.database();
                
                // Создаем ссылку на состояние колеса
                wheelStateRef = db.ref('wheelState');
                configRef = db.ref('wheelConfig');
                connectedRef = db.ref('.info/connected');
                historyRef = db.ref('history');
                chatRootRef = db.ref('chat');
                chatMessagesRef = db.ref('chat/messages');
                chatTypingRef = db.ref('chat/typing');
                
                // Гарантируем существование коллекции history
                historyRef.once('value', (snapshot) => {
                    if (!snapshot.exists()) {
                        historyRef.set({ _createdAt: Date.now() });
                    }
                });
                // Гарантируем существование корня чата и списков
                chatRootRef.once('value', (snapshot) => {
                    if (!snapshot.exists()) {
                        chatRootRef.set({ _createdAt: Date.now() });
                    }
                });
                chatMessagesRef.once('value', (snapshot) => {
                    if (!snapshot.exists()) {
                        chatMessagesRef.set({ _createdAt: Date.now() });
                    }
                });
                chatTypingRef.once('value', (snapshot) => {
                    if (!snapshot.exists()) {
                        chatTypingRef.set({ _createdAt: Date.now() });
                    }
                });
                
                // Устанавливаем дефолтную конфигурацию при первом запуске
                configRef.once('value', (snapshot) => {
                    if (!snapshot.exists()) {
                        const noCount = parseInt(yesCountInput.value) || 0;
                        const yesCount = 10 - noCount;
                        const reason = reasonInput.value || '';
                        configRef.set({ noCount, yesCount, reason });
                    }
                });
                
                // Слушаем изменения конфигурации
                configRef.on('value', (snapshot) => {
                    const config = snapshot.val();
                    if (config) {
                        const no = Math.min(Math.max(parseInt(config.noCount) || 0, 0), 9);
                        yesCountInput.value = no;
                        reasonInput.value = config.reason || '';
                        initWheel(no);
                    }
                });
                
                // Отслеживаем количество подключенных пользователей
                const usersRef = db.ref('users');
                const userRef = usersRef.push();
                
                userRef.set(true);
                userRef.onDisconnect().remove();
                
                usersRef.on('value', (snapshot) => {
                    usersOnline = snapshot.numChildren();
                    onlineCountElement.textContent = `Пользователей онлайн: ${usersOnline}`;
                });

                // Рендер истории (новые сверху)
                if (historyRef && historyListEl) {
                    historyRef.limitToLast(200).on('value', (snapshot) => {
                        const data = snapshot.val() || {};
                        const entries = Object.entries(data)
                            .filter(([key]) => key !== '_createdAt')
                            .map(([, v]) => v)
                            .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
                        historyListEl.innerHTML = '';
                        entries.forEach((e) => {
                            const dt = e.isoDate || new Date(e.timestamp || 0).toISOString();
                            const reasonText = (e.reason || '').trim();
                            const label = e.result === 'ДА' ? 'ДА' : 'NO';
                            const color = e.result === 'ДА' ? '#27ae60' : '#e74c3c';
                            const noCount = typeof e.noCount === 'number' ? e.noCount : 0;

                            const item = document.createElement('div');
                            item.className = 'history-item';

                            const metaEl = document.createElement('div');
                            metaEl.className = 'meta';
                            metaEl.textContent = dt;

                            const reasonEl = document.createElement('div');
                            reasonEl.className = 'reason';
                            const reasonContent = reasonText ? renderTextWithSpoilers(reasonText) : document.createTextNode('—');
                            reasonEl.appendChild(reasonContent);

                            const maxEl = document.createElement('div');
                            maxEl.className = 'meta';
                            maxEl.textContent = `МАКС: ${noCount}/10`;

                            const resultEl = document.createElement('div');
                            resultEl.className = 'result';
                            resultEl.style.color = color;
                            resultEl.textContent = label;

                            item.appendChild(metaEl);
                            item.appendChild(reasonEl);
                            item.appendChild(maxEl);
                            item.appendChild(resultEl);
                            historyListEl.appendChild(item);
                        });
                    });
                }
                
                connectionStatus.textContent = 'Подключено к Firebase';
                connectionStatus.className = 'status connected';
                initChatRealtime();
                
            } catch (error) {
                console.error('Ошибка инициализации Firebase:', error);
                connectionStatus.textContent = 'Ошибка подключения: ' + error.message;
                connectionStatus.className = 'status disconnected';
            }
        }

        // Chat: render one message
        function appendChatMessage(msg, isMe, key) {
            const wrap = document.createElement('div');
            wrap.className = `chat-message${isMe ? ' me' : ''}`;
            const textSpan = document.createElement('span');
            textSpan.textContent = msg.text || '';
            wrap.appendChild(textSpan);
            // Read indicator inside bubble (right side)
            const readEl = document.createElement('span');
            readEl.className = 'read-indicator';
            readEl.textContent = '✓';
            readEl.style.display = 'none';
            wrap.appendChild(readEl);

            const meta = document.createElement('div');
            meta.className = 'chat-meta';
            const dt = msg.isoDate || new Date(msg.timestamp || 0).toISOString();
            meta.textContent = dt;
            
            chatMessages.appendChild(wrap);
            chatMessages.appendChild(meta);
            chatMessages.scrollTop = chatMessages.scrollHeight;

            if (isMe && chatMessagesRef && key) {
                const seenRef = chatMessagesRef.child(key).child('seenBy');
                seenRef.on('value', (snap) => {
                    const val = snap.val() || {};
                    const someoneElseSeen = Object.keys(val).some((k) => k !== myDeviceId);
                    readEl.style.display = someoneElseSeen ? 'inline' : 'none';
                });
            }
        }

        // Chat: listeners and send/typing handlers
        function initChatRealtime() {
            if (!db) return;
            myDeviceId = localStorage.getItem('deviceId') || (() => {
                const id = Math.random().toString(36).slice(2);
                localStorage.setItem('deviceId', id);
                return id;
            })();
            myTypingRef = db.ref(`chat/typing/${myDeviceId}`);
            myTypingRef.onDisconnect().remove();

            // Messages: stream
            if (chatMessagesRef) {
                chatMessagesRef.limitToLast(200).on('child_added', (snap) => {
                    const msg = snap.val();
                    if (!msg || msg._createdAt) return;
                    const isMe = msg.deviceId === myDeviceId;
                    appendChatMessage(msg, isMe, snap.key);
                    // Mark as seen if message is from others
                    if (!isMe) {
                        try {
                            chatMessagesRef.child(snap.key).child('seenBy').child(myDeviceId).set(Date.now());
                        } catch (_) {}
                    }
                });
                // Update messages on change (e.g., seenBy updates) if needed
                chatMessagesRef.limitToLast(200).on('child_changed', (snap) => {
                    // No-op here because each own message has its own listener on seenBy
                });
            }

            // Typing indicator (someone else is typing)
            if (chatTypingRef) {
                chatTypingRef.on('value', (snap) => {
                    const val = snap.val() || {};
                    const othersTyping = Object.keys(val).some((k) => k !== myDeviceId);
                    chatTyping.style.display = othersTyping ? 'block' : 'none';
                });
            }

            // Send message
            function sendMessage() {
                const text = chatInput.value.trim();
                if (!text || !chatMessagesRef) return;
                const now = Date.now();
                const newMsgRef = chatMessagesRef.push();
                newMsgRef.set({
                    text,
                    timestamp: now,
                    isoDate: new Date(now).toISOString(),
                    deviceId: myDeviceId
                });
                chatInput.value = '';
            }
            chatSend.addEventListener('click', sendMessage);
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    sendMessage();
                }
            });

            // Typing
            let typingTimer = null;
            function setTyping(isTyping) {
                if (!myTypingRef) return;
                if (isTyping) {
                    myTypingRef.set({ timestamp: Date.now() });
                } else {
                    myTypingRef.remove();
                }
            }
            chatInput.addEventListener('input', () => {
                setTyping(true);
                if (typingTimer) clearTimeout(typingTimer);
                typingTimer = setTimeout(() => setTyping(false), 1500);
            });
        }

        // Сохранение конфигурации колеса в Firebase
        function saveConfigToFirebase() {
            if (!configRef) return;
            
            const noCount = parseInt(yesCountInput.value);
            
            if (noCount < 0 || noCount > 9) {
                alert('МАКС  должно быть от 0 до 9');
                return;
            }
            
            const yesCount = 10 - noCount;
            
            // Обновляем только yes/no, не трогаем reason
            configRef.update({
                noCount: noCount,
                yesCount: yesCount
            });
            
            initWheel(noCount);
        }
        
        // Дебаунс для уменьшения количества записей в БД при наборе
        function debounce(fn, delay) {
            let timerId;
            return function(...args) {
                clearTimeout(timerId);
                timerId = setTimeout(() => fn.apply(this, args), delay);
            };
        }

        // Обработчики событий
        spinBtn.addEventListener('click', spinWheel);
        
        // Реальное время: изменения инпутов сразу отправляются в Firebase
        let emptyFillTimer = null;
        const debouncedSave = debounce(() => {
            const raw = yesCountInput.value;
            // Если поле пустое — ждём 2 секунды, затем подставим 0 и сохраним
            if (raw === '' || raw == null) {
                if (emptyFillTimer) clearTimeout(emptyFillTimer);
                emptyFillTimer = setTimeout(() => {
                    yesCountInput.value = '0';
                    saveConfigToFirebase();
                    emptyFillTimer = null;
                }, 2000);
                return;
            }
            // Есть ввод — отменяем отложенную подстановку и сохраняем с нормализацией через 300 мс
            if (emptyFillTimer) {
                clearTimeout(emptyFillTimer);
                emptyFillTimer = null;
            }
            const noVal = Math.min(Math.max(parseInt(raw) || 0, 0), 9);
            if (String(noVal) !== raw) {
                yesCountInput.value = String(noVal);
            }
            saveConfigToFirebase();
        }, 300);
        yesCountInput.addEventListener('input', debouncedSave);
        
        // Дебаунс для «Повод»
        const debouncedSaveReason = debounce(() => {
            if (!configRef) return;
            const reason = reasonInput.value || '';
            // Обновляем только reason, не трогаем yes/no
            configRef.update({ reason });
        }, 400);
        reasonInput.addEventListener('input', debouncedSaveReason);
        
        saveConfigBtn.addEventListener('click', () => {
            const configText = firebaseConfigTextarea.value.trim();
            
            if (!configText) {
                alert('Введите конфигурацию Firebase');
                return;
            }
            
            try {
                // Пытаемся преобразовать текст конфигурации в объект
                const config = JSON.parse(configText);
                
                // Сохраняем конфигурацию в localStorage
                localStorage.setItem('firebaseConfig', JSON.stringify(config));
                
                // Инициализируем Firebase
                initFirebase(config);
                
            } catch (error) {
                alert('Ошибка в формате конфигурации: ' + error.message);
            }
        });
        
        // Загрузка сохраненной конфигурации при загрузке страницы
        window.addEventListener('DOMContentLoaded', () => {
            // Инициализируем колесо с значениями по умолчанию
            initWheel(0);
            
            // Проверяем, есть ли сохраненная конфигурация
            const savedConfig = localStorage.getItem('firebaseConfig');
            if (savedConfig) {
                try {
                    const config = JSON.parse(savedConfig);
                    firebaseConfigTextarea.value = JSON.stringify(config, null, 2);
                    initFirebase(config);
                } catch (error) {
                    console.error('Ошибка загрузки конфигурации:', error);
                }
            }
        });

        function renderTextWithSpoilers(text) {
            const t = String(text ?? '');
            const fragment = document.createDocumentFragment();
            let i = 0;
            while (i < t.length) {
                const start = t.indexOf('||', i);
                if (start === -1) {
                    // Остаток как обычный текст
                    fragment.appendChild(document.createTextNode(t.slice(i)));
                    break;
                }
                // Текст до спойлера
                if (start > i) {
                    fragment.appendChild(document.createTextNode(t.slice(i, start)));
                }
                const end = t.indexOf('||', start + 2);
                if (end === -1) {
                    // Нет закрывающего — всё остальное как текст
                    fragment.appendChild(document.createTextNode(t.slice(start)));
                    break;
                }
                // Содержимое спойлера
                const inner = t.slice(start + 2, end);
                const span = document.createElement('span');
                span.className = 'spoiler';
                span.textContent = inner;
                span.addEventListener('click', () => {
                    span.classList.toggle('revealed');
                });
                fragment.appendChild(span);
                i = end + 2;
            }
            return fragment;
        }

        // PIN logic
        const pinOverlay = document.getElementById('pinOverlay');
        const pinField = document.getElementById('pinField');
        const pinTitle = document.getElementById('pinTitle');
        const pinSubtitle = document.getElementById('pinSubtitle');
        const pinConfirm = document.getElementById('pinConfirm');
        const pinReset = document.getElementById('pinReset');
        const pinError = document.getElementById('pinError');
        
        function buildPinInputs() {
            pinField.innerHTML = '';
            for (let i = 0; i < 6; i++) {
                const inp = document.createElement('input');
                inp.type = 'password';
                inp.inputMode = 'numeric';
                inp.maxLength = 1;
                inp.autocomplete = 'off';
                inp.addEventListener('input', (e) => {
                    const v = e.target.value.replace(/\D/g, '');
                    e.target.value = v.slice(0, 1);
                    if (v && i < 5) pinField.children[i + 1].focus();
                });
                inp.addEventListener('keydown', (e) => {
                    if (e.key === 'Backspace' && !e.target.value && i > 0) {
                        pinField.children[i - 1].focus();
                    }
                });
                pinField.appendChild(inp);
            }
        }
        
        function readPinFromInputs() {
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += pinField.children[i].value || '';
            }
            return code;
        }
        
        function showPinOverlay(mode) {
            // mode: 'create' | 'enter'
            buildPinInputs();
            pinError.textContent = '';
            if (mode === 'create') {
                pinTitle.textContent = 'Создайте PIN';
                pinSubtitle.textContent = 'Придумайте 6-значный PIN. Запомните его!';
            } else {
                pinTitle.textContent = 'Введите PIN';
                pinSubtitle.textContent = 'Для доступа введите 6-значный PIN';
            }
            pinOverlay.classList.add('active');
            setTimeout(() => {
                const first = pinField.querySelector('input');
                if (first) first.focus();
            }, 0);
        }
        
        function hidePinOverlay() {
            pinOverlay.classList.remove('active');
        }
        
        function gateByPinOnLoad() {
            const storedPin = localStorage.getItem('wheel_pin');
            if (!storedPin) {
                showPinOverlay('create');
            } else {
                showPinOverlay('enter');
            }
        }
        
        pinConfirm.addEventListener('click', () => {
            const storedPin = localStorage.getItem('wheel_pin');
            const code = readPinFromInputs();
            if (!/^\d{6}$/.test(code)) {
                pinError.textContent = 'Введите 6 цифр';
                return;
            }
            if (!storedPin) {
                localStorage.setItem('wheel_pin', code);
                hidePinOverlay();
            } else {
                if (code === storedPin) {
                    hidePinOverlay();
                } else {
                    pinError.textContent = 'Неверный PIN';
                }
            }
        });
        
        pinReset.addEventListener('click', () => {
            // Reset PIN
            localStorage.removeItem('wheel_pin');
            
            // Reset Firebase configuration stored locally
            try {
                localStorage.removeItem('firebaseConfig');
            } catch (_) {}
            if (firebaseConfigTextarea) {
                firebaseConfigTextarea.value = '';
            }
            
            // Disconnect from Firebase and reset runtime refs/UI
            try {
                if (db) {
                    firebase.database().goOffline();
                }
            } catch (_) {}
            db = null;
            wheelStateRef = null;
            configRef = null;
            connectedRef = null;
            historyRef = null;
            
            if (connectionStatus) {
                connectionStatus.textContent = 'Не подключено';
                connectionStatus.className = 'status disconnected';
            }
            if (onlineCountElement) {
                onlineCountElement.textContent = 'Пользователей онлайн: 0';
            }
            
            // Return to create PIN flow
            showPinOverlay('create');
        });
        
        window.addEventListener('DOMContentLoaded', () => {
            gateByPinOnLoad();
        });

        // Chat drag (desktop)
        (function enableChatDrag() {
            if (!chatWidget || !chatHeader) return;
            let isDragging = false;
            let startX = 0;
            let startY = 0;
            let startLeft = 0;
            let startTop = 0;
            function onMouseDown(e) {
                // Only when fixed (desktop)
                const style = window.getComputedStyle(chatWidget);
                if (style.position !== 'fixed') return;
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                const rect = chatWidget.getBoundingClientRect();
                startLeft = rect.left;
                startTop = rect.top;
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }
            function onMouseMove(e) {
                if (!isDragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                const newLeft = Math.max(0, Math.min(window.innerWidth - chatWidget.offsetWidth, startLeft + dx));
                const newTop = Math.max(0, Math.min(window.innerHeight - chatWidget.offsetHeight, startTop + dy));
                chatWidget.style.left = newLeft + 'px';
                chatWidget.style.top = newTop + 'px';
                chatWidget.style.right = 'auto';
                chatWidget.style.bottom = 'auto';
            }
            function onMouseUp() {
                isDragging = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            }
            chatHeader.addEventListener('mousedown', onMouseDown);
        })();

        // Mobile: limit chat height to history height
        function updateChatMaxHeightMobile() {
            if (!chatWidget) return;
            const isMobile = window.innerWidth <= 1000;
            if (isMobile) {
                const historySection = document.querySelector('.history');
                if (historySection) {
                    const h = Math.max(0, historySection.getBoundingClientRect().height | 0);
                    if (h > 0) {
                        chatWidget.style.maxHeight = h + 'px';
                        return;
                    }
                }
                // Fallback if history not found
                chatWidget.style.maxHeight = '250px';
            } else {
                chatWidget.style.maxHeight = '50vh';
            }
        }
        window.addEventListener('resize', updateChatMaxHeightMobile);
        if (historyListEl) {
            const ro = new (window.ResizeObserver || function(cb){ this.observe = () => {}; })((entries) => {
                updateChatMaxHeightMobile();
            });
            try { ro.observe(historyListEl); } catch (_) {}
        }
        // Initial call after DOM ready
        window.addEventListener('DOMContentLoaded', updateChatMaxHeightMobile);
    </script>
</body>
</html>